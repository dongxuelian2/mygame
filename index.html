<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON ROGUE: OVERDRIVE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: white;
            font-family: 'Orbitron', sans-serif;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 5;
        }

        .hud-top {
            display: flex; justify-content: space-between; padding: 20px 40px; align-items: center;
        }

        .level-badge {
            font-size: 3rem; color: #ffd700; text-shadow: 0 0 15px #ffaa00; margin-right: 15px;
        }

        .xp-bar-container {
            width: 400px; height: 10px; background: rgba(255, 255, 255, 0.1); border: 1px solid #ffd700; position: relative;
        }
        #xp-fill { width: 0%; height: 100%; background: #ffd700; box-shadow: 0 0 10px #ffd700; transition: width 0.2s; }

        .stats-box { font-family: 'Rajdhani', sans-serif; text-align: right; font-size: 1.2rem; color: rgba(255,255,255,0.7); }

        .health-bar-container {
            width: 300px; height: 20px; background: rgba(255, 255, 255, 0.1); border: 1px solid #0ff; transform: skewX(-20deg); margin-top: 10px; position: relative; overflow: hidden;
        }
        #health-fill {
            width: 100%; height: 100%; background: linear-gradient(90deg, #ff0055, #ff5500); box-shadow: 0 0 15px #ff0055; transition: width 0.1s linear;
        }

        .skill-hud { position: absolute; bottom: 40px; right: 40px; text-align: right; }
        .skill-meter { width: 200px; height: 8px; background: rgba(255,255,255,0.1); border: 1px solid #f0f; margin-top: 5px; }
        #skill-fill { width: 0%; height: 100%; background: #f0f; transition: width 0.1s linear; }

        /* Screens */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(8px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; z-index: 20; opacity: 1; transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-size: 5rem; margin: 0;
            background: linear-gradient(to bottom, #fff, #0ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5); animation: glitch 2s infinite;
        }

        /* Upgrade Cards */
        #levelup-screen { background: rgba(10, 10, 20, 0.95); z-index: 30; }
        .cards-container { display: flex; gap: 30px; margin-top: 50px; }
        .card {
            width: 220px; height: 320px; background: rgba(0, 20, 40, 0.8); border: 2px solid #0ff; border-radius: 10px; padding: 20px;
            display: flex; flex-direction: column; align-items: center; text-align: center; cursor: pointer; transition: 0.3s; position: relative; overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
        }
        .card:hover { transform: translateY(-10px) scale(1.05); background: rgba(0, 40, 80, 0.9); border-color: #fff; box-shadow: 0 0 40px rgba(0, 255, 255, 0.4); }
        .card h3 { color: #ffd700; font-size: 1.5rem; margin-bottom: 10px; }
        .card .type { font-size: 0.8rem; color: #0ff; text-transform: uppercase; margin-bottom: 20px; letter-spacing: 2px; }
        .card p { font-family: 'Rajdhani', sans-serif; font-size: 1.1rem; color: #ddd; line-height: 1.4; }
        .card .rarity { position: absolute; bottom: 0; left: 0; width: 100%; height: 5px; }

        .btn {
            margin-top: 40px; padding: 15px 50px; font-family: 'Orbitron', sans-serif; font-size: 1.5rem; background: transparent; color: #0ff;
            border: 2px solid #0ff; cursor: pointer; text-transform: uppercase; letter-spacing: 3px; transition: 0.3s; box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        .btn:hover { background: #0ff; color: #000; box-shadow: 0 0 40px rgba(0, 255, 255, 0.8); }

        @keyframes glitch {
            0% { transform: translate(0); } 20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); } 100% { transform: translate(0); }
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top" id="hud" style="display:none;">
            <div style="display:flex; align-items:center;">
                <div class="level-badge">LV.<span id="levelEl">1</span></div>
                <div>
                    <div style="font-size:0.8rem; color:#ffd700; margin-bottom:5px;">EXP DATA</div>
                    <div class="xp-bar-container"><div id="xp-fill"></div></div>
                </div>
            </div>
            <div>
                <div class="stats-box">SCORE: <span id="scoreEl" style="color:#fff;">0</span></div>
                <div class="health-bar-container"><div id="health-fill"></div></div>
            </div>
        </div>

        <div class="skill-hud" id="skill-hud" style="display:none;">
            <div style="color:#f0f; font-weight:bold;">ULTIMATE [SPACE]</div>
            <div class="skill-meter"><div id="skill-fill"></div></div>
        </div>
    </div>

    <div id="start-screen" class="screen">
        <h1>NEON ROGUE</h1>
        <p>收集数据 . 升级核心 . 无限进化</p>
        <button class="btn" id="startBtn">初始化系统</button>
    </div>

    <div id="levelup-screen" class="screen hidden">
        <h2 style="font-size:3rem; color:#ffd700; text-shadow:0 0 20px #ff5500;">SYSTEM UPGRADE</h2>
        <div class="cards-container" id="cards-container"></div>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #ff0055;">SYSTEM FAILURE</h1>
        <p>生存时间: <span id="finalTime">0s</span> | 最终等级: <span id="finalLevel">1</span></p>
        <button class="btn" id="restartBtn">重启核心</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.querySelector('#gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI References
    const hud = document.querySelector('#hud');
    const scoreEl = document.querySelector('#scoreEl');
    const levelEl = document.querySelector('#levelEl');
    const xpFill = document.querySelector('#xp-fill');
    const healthFill = document.querySelector('#health-fill');
    const skillFill = document.querySelector('#skill-fill');
    const startScreen = document.querySelector('#start-screen');
    const levelUpScreen = document.querySelector('#levelup-screen');
    const cardsContainer = document.querySelector('#cards-container');
    const gameOverScreen = document.querySelector('#game-over-screen');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

    // Config & State
    const CONFIG = { baseXp: 10, xpCurve: 1.2, healPerOrb: 3 }; // Healing amount here
    let game = { active: false, paused: false, score: 0, frames: 0, difficulty: 1, startTime: 0 };
    const keys = { w: false, a: false, s: false, d: false, space: false };
    const mouse = { x: canvas.width/2, y: canvas.height/2, down: false };

    window.addEventListener('keydown', e => {
        if(e.key === ' ') { if(!keys.space && game.active && !game.paused) player.activateSkill(); keys.space = true; }
        if(['w','a','s','d'].includes(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true;
    });
    window.addEventListener('keyup', e => {
        if(e.key === ' ') keys.space = false;
        if(['w','a','s','d'].includes(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false;
    });
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mousedown', () => mouse.down = true);
    window.addEventListener('mouseup', () => mouse.down = false);

    // ----------------------------------------------------------------
    // UPGRADE SYSTEM
    // ----------------------------------------------------------------
    const UPGRADES_POOL = [
        { id: 'multishot', name: '分裂协议', type: 'WEAPON', desc: '子弹数 +1，单发伤害略降', rarity: '#ff0055' },
        { id: 'firerate', name: '超频核心', type: 'STAT', desc: '射击速度 +20%', rarity: '#00ffaa' },
        { id: 'damage', name: '高能弹头', type: 'STAT', desc: '伤害 +25%，子弹体积变大', rarity: '#ffaa00' },
        { id: 'speed', name: '量子推进', type: 'MOVE', desc: '移动速度 +15%，更灵活', rarity: '#00ccff' },
        { id: 'magnet', name: '广域引力', type: 'UTIL', desc: '拾取范围 +40%', rarity: '#aa00ff' },
        { id: 'maxhp', name: '纳米装甲', type: 'DEFENSE', desc: '最大生命 +30 并治疗', rarity: '#00ff00' },
        { id: 'pierce', name: '穿甲弹', type: 'WEAPON', desc: '穿透能力 +1', rarity: '#ff0055' }
    ];

    function getRandomUpgrades(count) {
        let pool = [...UPGRADES_POOL];
        let selected = [];
        for(let i=0; i<count; i++) {
            if(pool.length === 0) break;
            const r = Math.floor(Math.random() * pool.length);
            selected.push(pool[r]);
            pool.splice(r, 1); 
        }
        return selected;
    }

    function applyUpgrade(upgrade) {
        switch(upgrade.id) {
            case 'multishot': player.shotCount++; player.damage *= 0.9; break;
            case 'firerate': player.fireRateDelay = Math.max(2, player.fireRateDelay * 0.8); break;
            case 'damage': player.damage *= 1.25; player.projectileSize += 1; break;
            case 'speed': player.speed *= 1.15; break;
            case 'magnet': player.magnetRadius *= 1.4; break;
            case 'maxhp': player.maxHp += 30; player.hp += 30; break;
            case 'pierce': player.pierceCount++; break;
        }
        createFloatingText(player.x, player.y - 40, upgrade.name + " INSTALLED", upgrade.rarity);
    }

    function showLevelUpScreen() {
        game.paused = true;
        levelUpScreen.classList.remove('hidden');
        cardsContainer.innerHTML = '';
        const options = getRandomUpgrades(3);
        options.forEach(upg => {
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `<div class="rarity" style="background:${upg.rarity}"></div><h3>${upg.name}</h3><div class="type" style="color:${upg.rarity}">${upg.type}</div><p>${upg.desc}</p>`;
            card.onclick = () => {
                applyUpgrade(upg);
                levelUpScreen.classList.add('hidden');
                game.paused = false;
                animate();
            };
            cardsContainer.appendChild(card);
        });
    }

    // ----------------------------------------------------------------
    // GAME OBJECTS
    // ----------------------------------------------------------------

    class ExpOrb {
        constructor(x, y, value) {
            this.x = x; this.y = y; this.value = value;
            this.radius = 4; this.color = '#ffd700';
            this.vx = (Math.random()-0.5)*2; this.vy = (Math.random()-0.5)*2;
            this.magnetized = false;
        }
        update(player) {
            if (!this.magnetized) {
                this.x += this.vx; this.y += this.vy;
                this.vx *= 0.95; this.vy *= 0.95;
            }
            const dist = Math.hypot(player.x - this.x, player.y - this.y);
            if (dist < player.magnetRadius) {
                this.magnetized = true;
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * 12; // Fast suck speed
                this.y += Math.sin(angle) * 12;
            }
            // Draw
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color; ctx.shadowBlur = 8;
            ctx.fill();
            return dist < player.radius + this.radius;
        }
    }

    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x; this.y = y; this.text = text; this.color = color;
            this.life = 60; this.vy = -1;
        }
        update() {
            this.y += this.vy; this.life--;
            ctx.save();
            ctx.globalAlpha = Math.max(0, this.life / 60);
            ctx.fillStyle = this.color;
            ctx.font = 'bold 14px "Orbitron"';
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
            return this.life <= 0;
        }
    }

    class Particle {
        constructor(x, y, radius, color, velocity) {
            this.x = x; this.y = y; this.radius = radius;
            this.color = color; this.velocity = velocity;
            this.alpha = 1;
        }
        update() {
            this.velocity.x *= 0.92; this.velocity.y *= 0.92;
            this.x += this.velocity.x; this.y += this.velocity.y;
            this.alpha -= 0.04;
            ctx.save();
            ctx.globalAlpha = Math.max(0, this.alpha);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
            return this.alpha <= 0;
        }
    }

    class Projectile {
        constructor(x, y, radius, color, velocity, damage, pierce) {
            this.x = x; this.y = y; this.radius = radius;
            this.color = color; this.velocity = velocity;
            this.damage = damage; this.pierce = pierce;
            this.hitList = [];
        }
        update() {
            this.x += this.velocity.x; this.y += this.velocity.y;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color; ctx.shadowBlur = 15;
            ctx.fill();
        }
    }

    class Enemy {
        constructor(x, y, radius, color, speed, hp, type) {
            this.x = x; this.y = y; this.radius = radius;
            this.color = color; this.speed = speed;
            this.maxHp = hp; this.hp = hp; this.type = type;
            this.id = Math.random(); this.angle = 0;
        }
        update(player) {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;

            ctx.save();
            ctx.translate(this.x, this.y);
            if(this.type === 'spinner') {
                this.angle += 0.15;
                ctx.rotate(this.angle);
                ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2);
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 10;
            ctx.restore();
        }
    }

    class Player {
        constructor() {
            this.x = canvas.width/2; this.y = canvas.height/2;
            this.radius = 15; this.color = '#00ffff';
            this.velocity = {x:0, y:0};
            
            this.speed = 1.0;
            this.maxHp = 100; this.hp = 100;
            this.damage = 15; this.projectileSize = 4;
            this.shotCount = 1; this.pierceCount = 0;
            this.fireRateDelay = 7; // Faster default
            this.magnetRadius = 120; // Bigger default
            
            this.level = 1; this.xp = 0; this.nextLevelXp = CONFIG.baseXp;
            this.skillMeter = 0; this.skillMax = 100;
        }

        gainXp(amount) {
            this.xp += amount;
            // Healing Mechanism
            if(this.hp < this.maxHp) {
                this.hp = Math.min(this.maxHp, this.hp + CONFIG.healPerOrb);
                createFloatingText(this.x, this.y - 20, "+HP", "#0f0");
            }

            if(this.xp >= this.nextLevelXp) {
                this.xp -= this.nextLevelXp;
                this.level++;
                this.nextLevelXp = Math.floor(this.nextLevelXp * CONFIG.xpCurve);
                createFloatingText(this.x, this.y - 50, "LEVEL UP!", "#fff");
                showLevelUpScreen();
            }
            this.updateUI();
        }

        updateUI() {
            xpFill.style.width = `${(this.xp / this.nextLevelXp) * 100}%`;
            levelEl.innerText = this.level;
            healthFill.style.width = `${Math.max(0, (this.hp / this.maxHp) * 100)}%`;
            skillFill.style.width = `${(this.skillMeter / this.skillMax) * 100}%`;
        }

        update() {
            // Movement Physics
            if(keys.w) this.velocity.y -= this.speed;
            if(keys.s) this.velocity.y += this.speed;
            if(keys.a) this.velocity.x -= this.speed;
            if(keys.d) this.velocity.x += this.speed;
            
            this.velocity.x *= 0.92; this.velocity.y *= 0.92; // Inertia
            this.x += this.velocity.x; this.y += this.velocity.y;
            
            // Boundaries
            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
            this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

            // Draw
            ctx.save();
            ctx.translate(this.x, this.y);
            const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
            ctx.rotate(angle);

            // 1. Engine Flame Animation (Restored!)
            if(keys.w || keys.a || keys.s || keys.d) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(-15, -5);
                ctx.lineTo(-25 - Math.random()*15, 0); // Flickering tail
                ctx.lineTo(-15, 5);
                ctx.fillStyle = '#ffaa00';
                ctx.shadowColor = '#ff5500';
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.restore();
            }

            // 2. Player Body
            ctx.shadowColor = this.color; ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2);
            ctx.fillStyle = this.color; ctx.fill();
            
            // 3. Turret
            ctx.fillStyle = '#fff'; ctx.fillRect(0, -5, 22, 10);
            
            ctx.restore();

            if(this.skillMeter < this.skillMax) this.skillMeter += 0.1;
            this.updateUI();
        }

        activateSkill() {
            this.skillMeter = 0;
            screenShake(25);
            for(let i=0; i<48; i++) {
                const angle = (Math.PI*2/48)*i;
                const v = { x: Math.cos(angle)*18, y: Math.sin(angle)*18 };
                projectiles.push(new Projectile(this.x, this.y, 6, '#f0f', v, this.damage*4, 999));
            }
        }
    }

    // ----------------------------------------------------------------
    // MAIN LOOP
    // ----------------------------------------------------------------

    let player, projectiles, enemies, particles, xpOrbs, texts, shakeIntensity;

    function init() {
        player = new Player();
        projectiles = []; enemies = []; particles = []; xpOrbs = []; texts = [];
        shakeIntensity = 0;
        game.score = 0; game.frames = 0; game.difficulty = 1; game.active = true; game.paused = false;
        game.startTime = Date.now();
        scoreEl.innerText = '0';
        hud.style.display = 'flex';
        document.querySelector('#skill-hud').style.display = 'block';
    }

    function createFloatingText(x, y, text, color) { texts.push(new FloatingText(x, y, text, color)); }
    function screenShake(amount) { shakeIntensity = amount; }

    function spawnEnemy() {
        const spawnRate = Math.max(15, 60 - Math.floor(game.frames / 500) * 4);
        if (game.frames % spawnRate === 0) {
            const r = Math.random() < 0.5;
            const x = r ? (Math.random()<0.5 ? -30 : canvas.width+30) : Math.random()*canvas.width;
            const y = !r ? (Math.random()<0.5 ? -30 : canvas.height+30) : Math.random()*canvas.height;
            const diffMult = 1 + (game.frames / 5000); // Slower difficulty scaling
            
            let hp = 15 * diffMult; let speed = (Math.random() * 1.5 + 0.5);
            let color = '#ff3366'; let radius = 15; let type = 'basic';

            if(Math.random() > 0.85) {
                type = 'spinner'; hp *= 2.5; speed *= 0.6; color = '#aa00ff'; radius = 22;
            } else if (Math.random() > 0.92) {
                type = 'rusher'; hp *= 0.6; speed *= 2.2; color = '#ffaa00'; radius = 12;
            }
            enemies.push(new Enemy(x, y, radius, color, speed, hp, type));
        }
    }

    function animate() {
        if(!game.active) return;
        if(game.paused) return;

        requestAnimationFrame(animate);

        // Clear & Shake
        ctx.fillStyle = 'rgba(5, 5, 8, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if(shakeIntensity > 0) {
            ctx.save();
            ctx.translate((Math.random()-0.5)*shakeIntensity, (Math.random()-0.5)*shakeIntensity);
            shakeIntensity *= 0.9;
            if(shakeIntensity < 0.5) shakeIntensity = 0;
        }

        player.update();

        // Shooting Logic (With Recoil!)
        if(mouse.down && game.frames % Math.floor(player.fireRateDelay) === 0) {
            const baseAngle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            
            // Apply Recoil to Player
            const recoilForce = 3;
            player.velocity.x -= Math.cos(baseAngle) * recoilForce;
            player.velocity.y -= Math.sin(baseAngle) * recoilForce;
            
            // Screen kick
            screenShake(2);

            // Muzzle Flash
            particles.push(new Particle(player.x + Math.cos(baseAngle)*20, player.y + Math.sin(baseAngle)*20, 8, '#fff', {x:0, y:0}));

            const totalSpread = Math.PI / 4;
            const startAngle = baseAngle - (player.shotCount > 1 ? totalSpread / 2 : 0);
            const step = player.shotCount > 1 ? totalSpread / (player.shotCount - 1) : 0;

            for(let i=0; i<player.shotCount; i++) {
                const angle = startAngle + (step * i);
                const vel = { x: Math.cos(angle) * 16, y: Math.sin(angle) * 16 };
                projectiles.push(new Projectile(player.x, player.y, player.projectileSize, '#fff', vel, player.damage, player.pierceCount));
            }
        }

        // --- Updates & Collisions ---
        
        // XP Orbs
        for(let i = xpOrbs.length - 1; i >= 0; i--) {
            if(xpOrbs[i].update(player)) {
                player.gainXp(xpOrbs[i].value);
                xpOrbs.splice(i, 1);
            }
        }

        // Projectiles
        for(let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            p.update();
            if(p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) { projectiles.splice(i, 1); continue; }
        }

        // Enemies
        for(let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            e.update(player);

            const distP = Math.hypot(player.x - e.x, player.y - e.y);
            if(distP < player.radius + e.radius) {
                player.hp -= 15; // Reduced damage taken
                screenShake(10);
                createFloatingText(player.x, player.y, "-HP", "#f00");
                enemies.splice(i, 1);
                if(player.hp <= 0) { endGame(); return; }
                player.updateUI();
                continue;
            }

            for(let j = projectiles.length - 1; j >= 0; j--) {
                const p = projectiles[j];
                if (p.hitList.includes(e.id)) continue;

                const dist = Math.hypot(p.x - e.x, p.y - e.y);
                if(dist < p.radius + e.radius) {
                    e.hp -= p.damage;
                    createFloatingText(e.x, e.y, Math.floor(p.damage), '#fff');
                    for(let k=0; k<2; k++) particles.push(new Particle(e.x, e.y, Math.random()*3, e.color, {x:(Math.random()-.5)*5, y:(Math.random()-.5)*5}));

                    if(p.pierce > 0) { p.pierce--; p.hitList.push(e.id); } 
                    else { projectiles.splice(j, 1); }
                    
                    if(e.hp <= 0) {
                        enemies.splice(i, 1);
                        game.score += 10;
                        scoreEl.innerText = game.score;
                        xpOrbs.push(new ExpOrb(e.x, e.y, 10));
                        for(let k=0; k<8; k++) particles.push(new Particle(e.x, e.y, Math.random()*4, e.color, {x:(Math.random()-.5)*8, y:(Math.random()-.5)*8}));
                    }
                    break;
                }
            }
        }

        for(let i = particles.length - 1; i >= 0; i--) {
            if(particles[i].update()) particles.splice(i, 1);
        }
        for(let i = texts.length - 1; i >= 0; i--) {
            if(texts[i].update()) texts.splice(i, 1);
        }

        if(shakeIntensity > 0) ctx.restore();
        spawnEnemy();
        game.frames++;
    }

    function endGame() {
        game.active = false;
        hud.style.display = 'none'; document.querySelector('#skill-hud').style.display = 'none';
        gameOverScreen.classList.remove('hidden');
        document.querySelector('#finalTime').innerText = Math.floor((Date.now() - game.startTime)/1000) + 's';
        document.querySelector('#finalLevel').innerText = player.level;
    }

    document.querySelector('#startBtn').onclick = () => { startScreen.classList.add('hidden'); init(); animate(); };
    document.querySelector('#restartBtn').onclick = () => { gameOverScreen.classList.add('hidden'); init(); animate(); };

</script>
</body>
</html>
